---
title: "Forecasting Chicago Divvy Bike Ridership"
author: "Keith Hultman"
date: "April 22, 2017"
output: html_notebook
---

## Introduction

Divvy is a bike sharing system for the city of Chicago that provides residents and tourists an option for getting around the city. After patrons purchase a daily or annual pass, they can unlock a bike, ride to their destination, and return the bike to one of the Divvy bike docking stations found throughout the city. The daily and annual pass includes 30 minutes of riding time, with additional fees for longer trips. The program is designed to promote short one-way trips to increase sharing of the bikes throughout the day. The program currently has 6,000 bikes at over 580 bike stations and there are similar bike sharing programs in other cities, including Montreal and Boston.  

The motivation to forecast Divvy bike use would be beneficial for Divvy's operating company, Motivate, and the Chicago Department of Transportation for the following reasons.

1. Predicting the demand for the next season would aid plans on future expansion or price changes to opimize bike use and profitability.
2. On a granular level, identifying the patterns of use for each bike station would allow the Divvy program to opimize bike placement and availability. Stations that are predicted to have increasing use can be expanded for additional Divvy bike slots, and it may be necessary to transport bikes from one station to another.
3. The Divvy program can be used as a measure of transportation activity in the city and can tell us how people move about the city on a day-to-day and week-to-week basis. 

## Exploring the Divvy data

I will first try to model the daily duration of Divvy rides for all bike stations in the city. The data was collected from the [City of Chicago Data Portal](https://data.cityofchicago.org). The original data was summarized using the Data Portal Filter by summing the daily duration of each trip, and then exported to a csv file. The summarized data is public and available [here](https://data.cityofchicago.org/Transportation/Divy_daily_duration/3hs6-p2qv). The duration is total hours of bike usage per day. 

```{r Load data, message=FALSE, warning=FALSE}
library(tidyverse)
library(lubridate)
library(forecast)

divvy <- read_csv("data/divvy_daily_duration.csv")

divvy$date <- mdy(divvy$`START TIME`)
divvy$`START TIME` <- NULL
divvy$duration <- divvy$`TRIP DURATION`
divvy$`TRIP DURATION` <- NULL
```

First we will look at the overall time series and examine its features. 

```{r Time series plot, fig.cap="Divvy Bike Time Series"}
library(xts)
divvy_xts <- xts(divvy$duration, order.by = divvy$date)
autoplot(divvy_xts) + ggtitle("Divvy daily ridership duration") + ylab("Hours per day") + xlab("Year")
```

We can see that ridership appears to have increased during the first three years of Divvy availability and possibly leveled off during 2016, the last year of available data. There is also clear yearly seasonality, which is expected given how difficult it is to ride a bicycle during Chicago's winters. 

Since Divvy is used by many commuters, its possible there is also weekly seasonality as well. However, let't take a closer look at 4 weeks of data in May 2016.

```{r Seasonal plot}
plot(divvy_xts['2016-05-01/2016-05-28'])
divvy_ts <- ts(divvy_xts['2014/2016-12-31'], start = c(2014, 1), frequency = 365)
ggseasonplot(divvy_ts) + ggtitle("Seasonal plot of Divvy daily ridership")
```

During this time, there doesn't appear to be any obvious weekly seasonality to the data. We can also examine the subseries plot for each week day over all years.  

```{r Subseries plot}
divvy_w_ts <- ts(divvy_xts['2014/2016-12-31'], start = c(2014, 1), frequency = 7)
ggsubseriesplot(divvy_w_ts) + ggtitle("Subseries plot for weekly seasonality")
```

This does look like there is some seasonality with the highest volume of traffic on Monday's and Tuesdays. 

To explore annual trends we can combine the data into a weekly and monthly series.

```{r Roll up}
divvy_w <- divvy %>% group_by(week = as.POSIXct(cut(date, "week"))) %>% summarise(weekly_rides = sum(duration))
divvy_m <- divvy %>% group_by(month = as.POSIXct(cut(date, "month"))) %>% summarise(monthly_rides = sum(duration))
```

Let's split out the latter half of 2016 as a test set so that we can examine how well our models predict future Divvy bike rider duration. 

```{r Train test split}
divvy_d_test <- divvy_xts['2016-07-01/2016-12-31']
divvy_w_test <- divvy_w %>% filter(week >= "2016-07-01")
divvy_m_test <- divvy_m %>% filter(month >= "2016-07-01")

divvy_d_train <- divvy_xts['2013/2016-07-01']
divvy_w_train <- divvy_w %>% filter(week < "2016-07-01")
divvy_m_train <- divvy_m %>% filter(month < "2016-07-01")

tail(divvy_m_train)
divvy_m_train <- xts(divvy_m_train$monthly_rides, order.by = divvy_m_train$month)
```

## Modeling monthly 

Let's first try modeling the longer term series with monthly data, first with an auto ETS damped model. 

```{r ETS}
fit1 <- ets(divvy_m_train, damped = TRUE)
summary(fit1)
autoplot(fit1)
autoplot(forecast(fit1, h = 6))
```


This does not appear to be a good forecast, since there is no accounting for seasonality. 

### Arima 

Next, we will try exploring a seasonal Arima model. First, let's look at the ACF and PACF plots on the orininal series. 

```{r Arima plots}
ggtsdisplay(divvy_m_train, main="Monthly Divvy Usage")
```

Using a Lag of 12 first to remove the seasonality.

```{r Differenced by 12}
ggtsdisplay(diff(divvy_m_train, lag = 12))
```

Then a second differencing to remove autocorrelation from first lag. 

```{r Differenced by 12 and 1}
ggtsdisplay(diff(diff(divvy_m_train, lag = 12)))
```

This now appears to be stationary. 

```{r Arima modeling}
fit2 <- Arima(divvy_m_train, order = c(0,1,1), seasonal = list(order = c(0,1,1), period = 12))
fit3 <- Arima(divvy_m_train, order = c(0,1,0), seasonal = list(order = c(0,1,1), period = 12))
fit4 <- Arima(divvy_m_train, order = c(0,1,1), seasonal = list(order = c(0,1,0), period = 12))
fit5 <- Arima(divvy_m_train, order = c(1,1,0), seasonal = list(order = c(0,1,0), period = 12))
fit2$aic
fit3$aic
fit4$aic
fit5$aic
```

The Arima model with the lowest AIC is an $ARIMA(1,1,0)(0,1,0)_{12}$

```{r Arima forecast}
forecast5 <- forecast(fit5, h=12)
plot(forecast5)
```


### Prophet

```{r}
library(prophet)
divvy_m_prophet <- data.frame(ds = divvy_m$month, y = divvy_m$monthly_rides)

m <- prophet(divvy_m_prophet)

future <- make_future_dataframe(m, periods = 12)

forecast <- predict(m, future)

plot(m, forecast)
```

## Modeling daily Divvy durration within the year

Let's now try and model the daily duration data using a Double-Seasonal ETS with ARMA errors. 

```{r}
ggtsdisplay(divvy_d_train)

divvy_d_msts <- msts(divvy_d_train, seasonal.periods = c(365.25))
fit11 <- tbats(divvy_d_msts)
fc11 <- forecast(fit11, h=184)
plot(fc11)

```

```{r}
divvy_d_prophet <- data.frame(ds = divvy$date, y = divvy$duration)
divvy_d_prophet_train <- divvy_d_prophet %>% filter(ds < "2016-07-01")

d <- prophet(divvy_d_prophet_train)

future <- make_future_dataframe(d, periods = 184)
forecast <- predict(d, future)

plot(d, forecast)

prophet_plot_components(d, forecast)
```











